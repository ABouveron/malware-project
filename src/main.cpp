// projet.cpp : définit le point d'entrée pour l'application console.
//c:\\documents and settings\\administrateur\\mes documents\\visual studio 2010\\Projects\\injection\\Release\\injection.dll
#include "stdafx.h"
#include <windows.h>
#include <string.h>
#include <tlhelp32.h>

// to get pif by name of exe
DWORD GetPidByName(const char* name){
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	char buf[MAX_PATH] = { 0 };
	size_t charsConverted = 0;

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (Process32First(snapshot, &entry)) {
        while(Process32Next(snapshot, &entry)) {
			wcstombs_s(&charsConverted, buf, entry.szExeFile, MAX_PATH);  
			if(_stricmp(buf, name)){
				HANDLE ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(entry.th32ProcessID));
				if(ph != NULL){
					printf("process on: %d\n", entry.th32ProcessID);
					CloseHandle(snapshot);
					return entry.th32ProcessID;
				}else{
					printf("could not obtain handle on %d\n", entry.th32ProcessID);
				}
			}
        }
    }

    CloseHandle(snapshot);
    return 0;  // Process ID not found
}

// to start a new process
int StartNewProcess(const char* processName){
	const char* prependChars = "C:\\Windows\\System32\\";
	size_t originalLength = strlen(processName);
	size_t prependLength = strlen(prependChars);
	char* modifiedName = new char[prependLength + originalLength+1];
	strcpy_s(modifiedName, prependLength + originalLength + 1, prependChars);
	strcat_s(modifiedName, prependLength + originalLength + 1, processName);

	int wideLength = MultiByteToWideChar(CP_UTF8,0,modifiedName,-1,nullptr,0);
	wchar_t* wideProcessName = new wchar_t[wideLength];
	MultiByteToWideChar(CP_UTF8,0,modifiedName,-1,wideProcessName,wideLength);

	STARTUPINFO si = {sizeof(si)};
	PROCESS_INFORMATION pi;

	LPCTSTR applicationName = wideProcessName;
	LPTSTR commandLine = NULL;
	LPSECURITY_ATTRIBUTES processAttributes = NULL;
	LPSECURITY_ATTRIBUTES threadAttributes = NULL;
	BOOL inheritHandles = FALSE;
	DWORD creationFlags =0;
	LPVOID environment = NULL;
	LPCTSTR currentDirectory = NULL;
	LPSTARTUPINFO startupInfo = &si;
	LPPROCESS_INFORMATION processInformation = &pi;

	BOOL result = CreateProcess(
		applicationName,
		commandLine,
		processAttributes,
		threadAttributes,
		inheritHandles,
		creationFlags,
		environment,
		currentDirectory,
		startupInfo,
		processInformation);
	if(result){
		printf("%s process created successfully!\n", processName);
		printf("Process ID: %d", pi.dwProcessId);

		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		return pi.dwProcessId;
	}else{
		printf("Failed to create %s process. Error code: %d", processName, GetLastError());
		return 0;
	
	}

}

int _tmain(int argc, _TCHAR* argv[])
{
	HMODULE dllHandle;
	
	// Load the DLL to get its base address
	dllHandle = LoadLibrary(L"user32.dll");
    if(  dllHandle == NULL ) {
        printf("[!] Error: loading the DLL, 0x%.8x\n", (unsigned int) GetLastError());
	}else{
		printf("[*] Base address : 0x%.8x\n", (unsigned int) dllHandle);
	}
	// To get cmd.exe's process id
	DWORD pid = GetPidByName("cmd.exe");

	if(pid == 0 || pid == NULL){
		printf("starting new cmd...\n");
		pid = StartNewProcess("cmd.exe");
		if(pid ==0){
			printf("Error with creating a new process\n");
		}
	}
	HMODULE hKernel32 = GetModuleHandle(L"Kernel32");
	VOID *load_library = GetProcAddress(hKernel32, "LoadLibraryA");

	HANDLE cmd = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(pid));
	//from course
	char* dll = "C:\\documents and settings\\Administrateur\\mes documents\\visual studio 2010\\Projects\\injection\\Release\\injection.dll";
	char* dll_dans_notepad = (char*) VirtualAllocEx(cmd, NULL, strlen(dll)+1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	DWORD ecrites;
	WriteProcessMemory(cmd, dll_dans_notepad, dll, strlen(dll)+1, &ecrites);
	
	CreateRemoteThread(cmd, NULL, 0, (LPTHREAD_START_ROUTINE) load_library, dll_dans_notepad, 0, NULL);
	// WaitForSingleObject (...)
	
	while(1);
	return 0;
}

