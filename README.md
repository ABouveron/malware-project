# README.md

# Malware Equipe WAV

Membres du groupe :

- Armand Bouveron
- Victor de Moura Netto
- Wenjia Tang

Type du malware : 

- Type **B**

Outils utilisÃ©s : 

- VM Windows XP (VirtualBox, VMWare)
- IDA, Ghidra
- IDEs pour Ã©crire du code (Visual Studio, CLion, Visual Studio Code)

## Architecture du projet ğŸ›–

Le projet sur GitHub suit lâ€™architecture classique dâ€™un projet sur Visual Studio, avec lâ€™ajout de ce `[README.md](http://README.md)` et dâ€™un `.gitignore` :

- `malware_project.sln` qui est le fichier de configuration du projet
- donnÃ©es du projet dans `malware_project/`
    - `dllmain.cpp` qui est la DLL injectÃ©e
    - `malware_project.cpp`, le fichier principal contenant le code

## VÃ©rification de lâ€™entrÃ©e ğŸšª

Pour vÃ©rifier lâ€™entrÃ©e utilisateur, tous les caractÃ¨res sont examinÃ©s pour s'assurer qu'ils respectent les normes dÃ©finies par le projet, Ã  savoir les caractÃ¨res `[a-z]`, `[A-Z]` et `[0-9]`. Si l'entrÃ©e est conforme, un `echo` sera fait dans tous les cas.

## Anti-debug ğŸª²

Pour vÃ©rifier si le programme est exÃ©cutÃ© en mode dÃ©bogage, deux types de vÃ©rifications distincts sont effectuÃ©s :

- `IsDebuggerPresent()` rÃ©alise une vÃ©rification directe et renvoie un boolÃ©en indiquant si le programme est exÃ©cutÃ© en mode dÃ©bogage.
- D'un autre cÃ´tÃ©, `CheckRemoteDebuggerPresent(GetCurrentProcess(), &debug)` poursuit le mÃªme objectif, mais fonctionne d'une maniÃ¨re diffÃ©rente. Elle inspecte directement le processus dans le systÃ¨me pour dÃ©terminer si le programme est exÃ©cutÃ© en mode dÃ©bogage et transmet le rÃ©sultat Ã  partir de la variable `debug`.

Ces deux fonctions sont intÃ©grÃ©es dans le code afin d'Ã©viter toute tentative de dÃ©bogage de l'application.

## Injection de DLL ğŸ’‰

Dans notre malware, nous avons effectuÃ© une injection de DLL. Cette partie du programme est constituÃ©e de deux parties principales telles que localiser le processus de Notepad et injecter la librairie Ã  lâ€™intÃ©rieur. 

### Localiser le processus de Notepad ğŸ—’ï¸

Lâ€™objectif de la premiÃ¨re phase de lâ€™injection consiste Ã  localiser le processus de Notepad. Dans un premier temps, nous vÃ©rifions l'exÃ©cution de Notepad. Pour cela, nous avons besoin dâ€™appeler la fonction `GetPidByName` en passant le nom dâ€™exÃ©cutable de Notepad (`notepad.exe`) en tant quâ€™argument. Si un processus Notepad est en cours dâ€™exÃ©cution sur la machine, cette fonction va nous renvoyer le PID du processus de Notepad. En revanche, si aucun processus Notepad n'est en cours d'exÃ©cution, la fonction renverra 0. Dans ce cas-lÃ , nous allons appeler la deuxiÃ¨me fonction `StartNewProcess`, qui nous permet de lancer un nouveau processus Notepad. De la mÃªme maniÃ¨re, cette fonction va nous renvoyer le PID de ce nouveau processus Notepad.

### Injecter la librairie dans Notepad ğŸ¥·

Une fois que nous avons obtenu le PID de Notepad, nous sommons prÃªts Ã  procÃ©der Ã  lâ€™injection de la librairie dans Notepad. Il est important de souligner que lâ€™objectif de cette injection nâ€™est pas de modifier de faÃ§on importante la librairie dans Notepad (câ€™est de lâ€™offuscation, qui sera expliquÃ©e dans la section `Offuscation`), mais plutÃ´t de bloquer les interactions de lâ€™utilisateur en utilisant la fonction `BlockInput`. Ainsi, dÃ¨s que la bibliothÃ¨que est chargÃ©e ou dÃ©chargÃ©e de Notepad, les entrÃ©es de l'utilisateur seront bloquÃ©es. SimultanÃ©ment, une fenÃªtre sera Ã©galement affichÃ©e.

## Destruction de Windows ğŸ’¥

Il existe plusieurs faÃ§ons de dÃ©truire la machine Windows, mais celle que nous avons choisie est de travailler avec le dossier System32. Ce dossier contient plusieurs fichiers et DLLs cruciaux pour le systÃ¨me Windows. Une fois supprimÃ©, le systÃ¨me arrÃªte de fonctionner. Cependant, la plupart des fichiers dans ce dossier sont protÃ©gÃ©s et ne peuvent donc pas Ãªtre modifiÃ©s. C'est pourquoi nous avons essayÃ© de supprimer autant de fichiers que possible en effectuant les actions suivantes :

```bash
start /b shutdown -s -f -t 3
```

Cette ligne programme un arrÃªt du systÃ¨me. Nous effectuons cette opÃ©ration avant de supprimer les fichiers du systÃ¨me, car si nous le faisions aprÃ¨s, la commande `shutdown` ne serait plus accessible.

```c
rd c:\\WINDOWS\\system32 /S /Q 2> nul
```

La deuxiÃ¨me ligne essaye de supprimer autant de fichiers que possible. Pour ce faire, nous utilisons un indicateur pour agir de maniÃ¨re silencieuse, c'est-Ã -dire sans avertir l'utilisateur de cette action, et nous supprimons toute sortie standard `stdout` afin de ne rien afficher dans le terminal.

### Chiffrement des appels systÃ¨mes ğŸ”’

Pour dissimuler les commandes utilisÃ©es dans les appels systÃ¨me et Ã©viter qu'elles ne soient facilement vues dans un dÃ©sassembleur, chaque caractÃ¨re des chaÃ®nes de caractÃ¨res a Ã©tÃ© modifiÃ©. Pour ceci, trois macros diffÃ©rentes ont Ã©tÃ© dÃ©finies :

```c
#define HIDE_LETTER(letter) Â  char((letter) + 0x60)
#define UNHIDE_STRING(str)Â  do { char * ptr = str ; while (*ptr) *ptr++ -= 0x60; } while(0)
#define HIDE_STRING(str)Â  do {char * ptr = str ; while (*ptr) *ptr++ += 0x60;} while(0)
```

Pour masquer un caractÃ¨re dans une chaÃ®ne de caractÃ¨res, on utilise la fonction `HIDE_LETTER`. Avant d'utiliser la chaÃ®ne, il est nÃ©cessaire d'appeler la fonction `UNHIDE_STRING` et juste aprÃ¨s son utilisation, la fonction `HIDE_STRING` est invoquÃ©e. Ces fonctions altÃ¨rent le contenu en mÃ©moire, rendant ainsi impossible sa visualisation dans un dÃ©sassembleur.

## Apparition de Windows ğŸªŸ

### Principe gÃ©nÃ©ral âœï¸

Le principe de ce piÃ¨ge est simplement dâ€™ouvrir en boucle des fenÃªtres sur le systÃ¨me de lâ€™utilisateur, de faÃ§on Ã  le rendre inutilisable car trop lent. Les fenÃªtres sâ€™affichent sur toute la surface utilisable de lâ€™Ã©cran de faÃ§on Ã  mobiliser le plus de ressources possible, et dâ€™empÃªcher toute intervention de lâ€™utilisateur.

Pour cela, on utilise la fonction `WndProc` qui permet de crÃ©er des fenÃªtres et on en crÃ©e en boucle (seulement 1 000 000 000). Elles sont aussi accompagnÃ©es dâ€™un `MessageBeep(MB_ICONHAND)`, pour plus dâ€™amusement. Les fenÃªtres demandent aussi lâ€™envoi dâ€™un BTC, au cas oÃ¹ lâ€™utilisateur serait trÃ¨s gÃ©nÃ©reux (ou naÃ¯f).

### Blocage des interactions ğŸš«

Un problÃ¨me important de ce genre de piÃ¨ge est que lâ€™utilisateur lanÃ§ant le programme peut toujours stopper lâ€™exÃ©cution, avec Ctrl-C ou en fermant lâ€™invite de commandes. Des protections ont donc Ã©tÃ© mises en place : 

- `CtrlHandler` permet de bloquer le Ctrl-C, le programme en cours ne peut donc plus Ãªtre interrompu.
- `CtrlHandler` ne peut pas bloquer lâ€™action de fermer lâ€™invite de commandes, mais peut lancer dâ€™autres processus. On relance donc le spam de fenÃªtres dÃ¨s que lâ€™utilisateur essaie de fermer le `cmd`, pour toujours plus de fenÃªtres.

Une fois le `CtrlHandler` crÃ©Ã©, il suffit de le mettre en place avec `SetConsoleCtrlHandler`. 

## VÃ©rification de clÃ© ğŸ”‘

Nous avons aussi implÃ©mentÃ© une vÃ©rification de clÃ©. Notre malware Ã©tant de type B, nous nâ€™avons en fait pas besoin de vÃ©rifier lâ€™entrÃ©e utilisateur pour savoir si lâ€™utilisateur a trouvÃ© la clÃ©, mais le but ici est simplement de troubler les personnes qui vont essayer dâ€™analyser notre code en rajoutant du code inutile, et notamment des opÃ©rations qui devraient Ãªtre remarquÃ©es en assembleur, comme des `XOR`.

Pour cela, nous avons donc fait deux chaÃ®nes de caractÃ¨res permettant de se vÃ©rifier lâ€™une lâ€™autre :

```c
char hello[11] = { 't' ^42, 'w' ^42, 'k' ^42, 'z' ^42, 'A' ^42, 'm' ^42, 'x' ^42, 'i' ^42, 'E' ^42, 'o' ^42, '\x00' ^42};
char verification[11] = { 't' ^40, 'w' ^40, 'k' ^40, 'z' ^40, 'A' ^40, 'm' ^40, 'x' ^40, 'i' ^40, 'E' ^40, 'o' ^40, '\x00' ^40};
```

Les chaÃ®nes de caractÃ¨res sont ensuite dÃ©chiffrÃ©es tout Ã  la fin du programme, dans un endroit situÃ© aprÃ¨s les piÃ¨ges, afin dâ€™assurer quâ€™il ne soit pas exÃ©cutÃ©, mais quâ€™elles ne soient pas non plus simplifiÃ©es par le compilateur.

## Offuscation ğŸŒªï¸

### Code inutile âš°ï¸

Nous avons rajoutÃ© du code inutile au milieu et Ã  lâ€™intÃ©rieur de toutes les autres fonctions. Les blocs de code ressemblent typiquement Ã  ceci : 

```c
for (int i=0; i<100; i++){
		i_2 = 1;
    i_2 *= 1.0001;
    i_2 ^= 70;
    for (int j=0; j<100; j++)
		    i_2++;
		i_2%=2;
}
```

### Offuscation dans lâ€™injection DLL ğŸ’¨

En ce qui concerne les offuscations lors de l'injection DLL, nous simulons une modification dans la sauvegarde de la bibliothÃ¨que de Notepad. Cependant, il est important de noter que l'utilisateur ne peut jamais accÃ©der Ã  la sauvegarde du fichier dans Notepad, Ã©tant donnÃ© qu'il est incapable d'utiliser sa souris et son clavier en raison du blocage effectuÃ©.

### Auto-modification ğŸš—

Nous avons une fonction appelÃ©e `MySecret`. Effectivement, cette fonction est inutile. Cependant, nous avons ajoutÃ© du code pour faire semblant de la modifier. Il faut remarquer que les modifications ne servent quâ€™Ã  Ã©craser la chaÃ®ne de caractÃ¨res Ã  afficher dans le terminal.